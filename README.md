<div>
<h1>Java</h1>
</div>
<br>
<div>
<h2> Java란? </h2>
<p>
&nbsp; 프로그래밍 언어 : 개발자와 운영체제가 소통하기 위한 언어이다.
</p>
</div>
<br>


<div>
<h2> 상속(inheritance)</h2>
<p>
  1. 기존에 선언된 클래스의 필드를 새롭게 만들 클래스의 필드로 사용하고자 할 때
</p>
<p>
  2. 여러 클래스 선언 시 필드가 겹치는 경우, 부모 클래스에서 먼저 선언하고 공통 필드를 묶어서 자식 클래스들에게 상속 해준다. 
</p>
</div>
<br>

<div>
<h2>다형성(polymorphism) - 메소드의 성질</h2>
<p>
  1. 오버로딩(overloading) : 매개변수의 개수 또는 타입이 다르면 동일한 이름의 메소드로 선언할 수 있다.
</p>
<p>
  2. 오버라이딩 : 부모 필드에서 선언한 메소드를 자식 필드에서 수정하고자 할 때 재정의를 해야한다. 
</p>
</div>
</div>
<br>

<div>
<h2> Casting </h2>
<p>
  1. up casting : 자식 값을 부모 타입으로 형변환
</p>
<p> &nbsp;  &nbsp;  &nbsp;  &nbsp; ex ) A 가 부모, B가 자식일 때 </p>
<p> &nbsp;  &nbsp;  &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  A a = new B(); </p>
<p>
  2. down castinf : up casting된 객체를 자식 타입으로 형변환
</p>
<p> &nbsp;  &nbsp;  &nbsp;  &nbsp; ex ) 부모 값을 자식 타입으로 형변환 시 오류 </p>
<p> &nbsp;  &nbsp;  &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  B b = (B)a; </p>
</div>
</div>
<br>


<div>
<h2> 추상 클래스</h2>
<p> &nbsp; 원래 모든 클래스가 추상적이지만 추상클래스가 추상적이다라는 뜻이 아니다.</p>
<p> &nbsp; 클래스안에서 선언된 필드안에서 추상적이다.</p>
<p> &nbsp; 추상메소드를 선언할 수 있는 것 </p>
</p>
</div>
<br>

<div>
<h2>인터페이스(interface) </h2>
<p> &nbsp; 추상클래스를 고도화시킨 문법</p>
<p> &nbsp; 상수와 추상메소드만 존재한다.</p>
<p> &nbsp; 구현은 인터페이스를 지정한 클래스에서 진행하고, 인터페이스를 다른 클래스에 지정할 때에는 implements 키워드를 사용한다.</p>
</div>
<br>

<div>
<h2>추상클래스와 인터페이스 간의 관계 </h2>
<p> &nbsp; 인터페이스를 클래스에 바로 지정하면 모든 메소드에 강제성이 부여되어서 전부 다 구현해야 한다.</p>
<p> &nbsp; 하지만 일반적인 상황에서는 모든 것이 아닌, 필요한 메소드를 골라서 재정의해야한다.</p>
<p> &nbsp; 인터페이스를 직접 지정하지 않고 다른 클래스에 지정한 후 바디를 만들어 놓든다면, 강제성이 소멸되고 이클래스를 상속받아서 필드를 구현한다면 골라서 재정의할 수 있게 된다.</p>
<p> &nbsp; 이때 중간에서 강제성을 없애주는 클래스를 추상클래스로 선언하기로 하며, 추상 클래스 이름뒤에는 Adapter를 붙여서 목적을 알려준다.</p>
</div>
<br>

<div>
<h2>내부 클래스(Inner Class) - 영역안에서 클래스 선언 가능  </h2>
<p> &nbsp; 하나의 클래스에서 a작업과 b작업이 있을 때에는 따로 분리하여 클래스로 만들지 않고, 클래스 안에 클래스를 선언하여 설계한다.</p>
<p> &nbsp; 이때 밖에 있는 클래스를 외부 클래스라고 하며, 안에 선언된 클래스를 내부 클래스라고 한다.</p>
<p> &nbsp; 외부 클래스가 메모리에 할당되어야 내부 클래스를 객체화 할 수 있기때문에 클래스를 숨기기 위해서 내부 클래스를 사용하기도 하며, </p>
<p> &nbsp; 이를 <strong>캡슐화</strong> 또는 <strong>은닉화</strong>라고 한다. </p>
<p> &nbsp; 내부 클래스는 외부 클래스의 필드이기 때문에 외부 클래스의 필드를 자신의 필드처럼 가져다 사용할 수 있게 된다.(상속의 개념은 아니다)</p>
<strong> &nbsp; ※ 메소드 안에서 클래스를 선언할 수도 있다.※ </strong>
</div>
<br>

<div>
<h2> 익명 클래스(Anonymous Inner Class)  </h2>
<p> &nbsp; 이름이 없는 클래스이며 구현되지 않은 필드를 구현하기 위해 일회성으로 생성되는 클래스이다.</p>
<strong> &nbsp; ※ 블록의 마지막에 세미콜론을 반드시 붙여야한다. ※  </strong>
</div>
<br>

<div>
<h2>다중 상속  </h2>
<p> &nbsp; 여러 부모 클래스를 상속하는 것을 다중 상속이라고 한다.</p>
<p> &nbsp; JAVA는 모호성 때문에 다중상속을 지원하지 않는다.</p>
<p> &nbsp; 하지만 JDK8버전부터는 인터페이스에 default 메소드 선언을 허용하며, 여러개를 지정할수 있는 인터페이스 특성상 다중상속을 지원하는 것이나 다름이 없다. </p>
</div>
<br>

<div>
<h2>모호성(ambiguity)</h2>
<p> &nbsp; 하나의 자식이 여러 부모를 상속받을때 부모 필드에 동일한 이름의 필드가 있다면, 어떤 부모의 필드인지 알 수가 없다. 이를 모호성이라고 부른다.</p>
</div>
<br>
	
<div>
<h2>함수형 인터페이스(Function interface)  </h2>
<p> &nbsp; 인터페이스 중 추상메소드를 하나만 가지고 있는 인터페이스를 함수형 인터페이스라고 한다.</p>
<p> &nbsp; 이때 @FuctionalInterface를 인터페이스 위에 작성하여 단 하나의 추상 메소드만 선언할 수 있도록 제한해야 한다.</p>
</div>
<br>

<div>
<h2>람다식(Lamda Expression)</h2>
<p> &nbsp; 이름이 없는 메소드로서 변수처럼 사용이 가능하며, 매개변수로도 전달이 가능하다.</p>
<p> &nbsp; 함수형 인터페이스는 추상 메소드가 딱 한개만 선언되기 때문에 메소드 이름이 필요없다.</p>
<p> &nbsp; 따라서 람다식을 익명 메소드(Anonymous Method)라고도 부른다.</p>
</div>
<br>
<div>
<h2>람다식 문법</h2>
<p> &nbsp; 1. (매개변수 형식 나열, ...) -> 리턴값;</p>
<p> &nbsp; 2. (매개변수 형식 나열, ...) -> {2개 이상의 문장 작성; return 리턴값;}</p>
</div>
<br>

